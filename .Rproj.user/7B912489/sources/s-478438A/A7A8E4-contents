---
title: 'ECON 680 : Dynamic Fisheries Management Problem'
author: "Dinesh R Poddaturi"
date: "3/8/2020"
output:
  pdf_document: default
  html_document:
    df_print: paged
---



Loading the packages
```{r message=FALSE, warning = FALSE }
require(tidyverse)
require(truncnorm)
require(nloptr)
require(optimx)
```

Function that creates Chebychev node vector
```{r eval=FALSE}
nodes <- function(xmin, xmax, n){
  x <- NA  
  for (i in 1:n){
     x[i] <- ((xmin + xmax)/2) + ((xmax - xmin)/2) *  cos( ((n-i+0.5)/n) * pi       )
  }
  
  return(x)

}
```


Function that creates and returns a chebychev interpolation matrix

```{r eval=FALSE}
chebychevMatrix <- function(x,xmin,xmax,n){
  z <- (2 * (x - xmin )/(xmax - xmin)) - 1
  mat <- matrix(data=0, nrow = length(z), ncol = n)
  for(i in 1:n){
      mat[,1] <- 1
      mat[,2] <- z
      if(i >=3){
        mat[,i] <- 2 * z * mat[,i-1] - mat[,i-2]
      }
  }
  return(mat)
}
```

Here we write the value function and gradiant of the value function in two seperate functions

```{r eval=FALSE}

valueFunction <- function(st,xt){
  
  x_node <- st + z * r * st * (1 - (st/K))
  v_pr <- t(z_probs) %*% chebychevMatrix(x = x_node, xmin = x_l, xmax = x_h, n = n) %*% c_old
  
  #Given cost function  
  cost <- (a/xt) * ((xt-st)^2)

  #Revenue 
  revenue <- p * (xt-st)

  #Profit function
  prof <- revenue - cost
  
  #This is the value
  v <- prof  + beta * v_pr
  
  return(-v)
}

#Gradient of the value function
grad_valueFunction <- function(st,xt){
  grad <- 2 * (a/xt) * (xt-st) - p
  return(grad)
  
}
```


```{r eval=FALSE}
#######################################################################
#################    baseline parameters    ###########################
#######################################################################

r <- 0.5
K <- 1
a <- 0.75
p <- 1
z_l <- 0.5
z_h <- 1.5
mu_z <- 1
var_z <- 0.1
beta <- 0.95

#######################################################################
#################    RANDOM SHOCKS    #################################
#######################################################################
n_z <- 15

z_seq <- seq(from=z_l, to=z_h, length.out = n_z)

z <- 0.5 * (z_seq[1:n_z-1] + z_seq[2:n_z])

#Now we get the cdfs of the shocks above
z_cdfs <- ptruncnorm(z_seq,  a=z_l, b=z_h, mean=mu_z, sd = sqrt(var_z))


z_cdfms <- 0.5 * (z_cdfs[1:n_z-1] + z_cdfs[2:n_z])

#We get the probabilities of the shocks
z_probs <- as.matrix(diff(z_cdfs),ncol=1)



#We normalize the fish stock to 1 (i.e., the upper bound for fish stock is 1).  
# Since our shocks are stochastic my upper bound is 2

x_l <- 0.01
x_h <- 1.7
n <- 10

cheb_nodes <- nodes(xmin = x_l, xmax = x_h, n = n)

phi_mat <- chebychevMatrix(x= cheb_nodes, xmin = x_l, xmax = x_h, n = n)


#######################################################################
#################    COLLOCATION METHOD    ############################
#######################################################################
collocationMethod <- function(nodes, phi_mat, n, z, z_probs){
          
      cheb_nodes <- nodes
  
      s <- as.matrix(numeric(n),ncol=1)
      c_old <- as.matrix(numeric(n),ncol=1)
      c <- as.matrix(numeric(n),ncol=1)
      v_new <- as.matrix(numeric(n),ncol=1)
      
      maxit <- 10000
      for(k in 1:maxit){
            c_old <- c
          
            for(i in 1:n){
              #st has the starting value and xt has the node
              st <- (cheb_nodes[i]+x_l)/2      
              xt <- cheb_nodes[i]      
                    
              #Here we perform the optimization      
              opts <- list("algorithm"="NLOPT_LD_MMA", "xtol_rel"=1.0e-8)      
              opt <- nloptr(x0 = st, eval_f = valueFunction, eval_grad_f = grad_valueFunction,  xt=xt, 
                            lb = x_l, ub = cheb_nodes[i], opts=opts)       
                                  
                    
              #this contains s_prime      
              s[i,] <- opt$solution      
                    
              #this contains value      
              v_new[i,] <- - opt$objective      
            }
        
        #here we are getting our new coefficients
        c <- solve(phi_mat) %*% v_new
        
        #here we check whether  old coefficients and new coefficients are close enough (to break the loop)
        if(norm(c-c_old) < 0.0001){
          break
        }
      }
      
      result <- cbind(c_old, s, v_new) %>% as.data.frame()
      names(result) <- c("c", "S", "V")
      return(result)
}
out <- collocationMethod(nodes = cheb_nodes, phi_mat = phi_mat, n = n, z = z, z_probs = z_probs)

```



 
```{r echo = FALSE, eval=FALSE}
out$c
```


Now we maximize our value function over entire space (Note: we use the collocation coefficients here)


```{r eval=FALSE}

#creating new sequence of stock (Note: these are not chebychev nodes)
x_space <- seq(from = x_l, to = x_h, length.out = 100)

s_star <- as.matrix(numeric(length(x_space)), ncol=1)
v_star <- as.matrix(numeric(length(x_space)), ncol=1)
h_star <- as.matrix(numeric(length(x_space)), ncol=1)

valueEntireSpace <- function(c, x_space, s_star, v_star){
    
    for(j in 1 : length(x_space)){
      #st has the starting value and xt has the node
      st <- (x_space[j]+x_l)/2            
      xt <- x_space[j]            
                  
      #Here we perform the optimization            
      opts <- list("algorithm"="NLOPT_LD_MMA", "xtol_rel"=1.0e-8)            
      opt <- nloptr(x0 = st, eval_f = valueFunction, eval_grad_f = grad_valueFunction,  
                    xt=xt, lb = x_l, ub = x_space[j], opts=opts)
      #this contains optimal s_prime
      s_star[j,] <- opt$solution                           
                                
      #this contains optimal value            
      v_star[j,] <- - opt$objective
    }
  
  h_star <- x_space - s_star
  
  result <- cbind(x_space, s_star, h_star ,v_star) %>% as.data.frame()
  names(result) <- c("Stock", "Escapement", "Harvest" ,"Value")
  return(result)
} 

optimalManagement <-  valueEntireSpace(c = out$c, x_space = x_space, s_star = s_star, v_star =  v_star)

```


```{r echo = FALSE, eval=FALSE}

ggplot(data = optimalManagement, aes(x= Stock, y = Harvest)) + geom_line(colour= "Blue")+ 
  ggtitle("Optimal Harvest (baseline)")+theme(plot.title = element_text(hjust = 0.5))

```



```{r echo = FALSE, eval=FALSE}
ggplot(data = optimalManagement, aes(x= Stock, y = Value)) + geom_line(colour= "Red")+ 
  ggtitle("Value (baseline)")+theme(plot.title = element_text(hjust = 0.5))
```


Here we change each parameter and see the optimal management policy 
```{r eval=FALSE}

r <- 0.75
out_r <- collocationMethod(nodes = cheb_nodes, phi_mat = phi_mat, n = n, z = z, z_probs = z_probs)
optimalManagement_r <-  valueEntireSpace(c = out_r$c, x_space = x_space, s_star = s_star, v_star =  v_star)

p <- 1.5
out_p <- collocationMethod(nodes = cheb_nodes, phi_mat = phi_mat, n = n, z = z, z_probs = z_probs)
optimalManagement_p <-  valueEntireSpace(c = out_p$c, x_space = x_space, s_star = s_star, v_star =  v_star)

a <- 1.15
out_a <- collocationMethod(nodes = cheb_nodes, phi_mat = phi_mat, n = n, z = z, z_probs = z_probs)
optimalManagement_a <-  valueEntireSpace(c = out_a$c, x_space = x_space, s_star = s_star, v_star =  v_star)

beta <- 0.875
out_beta <- collocationMethod(nodes = cheb_nodes, phi_mat = phi_mat, n = n, z = z, z_probs = z_probs)
optimalManagement_beta <-  valueEntireSpace(c = out_beta$c, x_space = x_space, s_star = s_star, v_star =  v_star)

```



```{r echo = FALSE, eval=FALSE}
harvestStatics <- ggplot(optimalManagement_r, aes(x=Stock)) 
harvestStatics <- harvestStatics + geom_line(aes(y=Harvest, colour="r=0.75")) 
harvestStatics <- harvestStatics + geom_line(aes(y=optimalManagement$Harvest, colour="r=0.5 (baseline)"))
harvestStatics <- harvestStatics + scale_colour_manual(values=c("blue", "red"))
harvestStatics <- harvestStatics + labs(y = "Optimal Harvest", x= "Stock", colour = "Parameter")
harvestStatics <- harvestStatics + theme(legend.position = c(0.65,0.8))
harvestStatics
```


```{r echo = FALSE, eval=FALSE}
vStatics <- ggplot(optimalManagement_r, aes(x=Stock)) 
vStatics <- vStatics + geom_line(aes(y=Value, colour="r=0.75")) 
vStatics <- vStatics + geom_line(aes(y=optimalManagement$Value, colour="r=0.5 (baseline)"))
vStatics <- vStatics + scale_colour_manual(values=c("blue", "red"))
vStatics <- vStatics + labs(y = "Value", x= "Stock", colour = "Parameter")
vStatics <- vStatics + theme(legend.position = c(0.9,0.6))
vStatics
```



```{r echo = FALSE, eval=FALSE}
harvestStatics <- ggplot(optimalManagement_p, aes(x=Stock)) 
harvestStatics <- harvestStatics + geom_line(aes(y=Harvest, colour="p=1.5")) 
harvestStatics <- harvestStatics + geom_line(aes(y=optimalManagement$Harvest, colour="p=1 (baseline)"))
harvestStatics <- harvestStatics + scale_colour_manual(values=c("blue", "red"))
harvestStatics <- harvestStatics + labs(y = "Optimal Harvest", x= "Stock", colour = "Parameter")
harvestStatics <- harvestStatics + theme(legend.position = c(0.6,0.8))
harvestStatics
```


```{r echo = FALSE, eval=FALSE}
vStatics <- ggplot(optimalManagement_p, aes(x=Stock)) 
vStatics <- vStatics + geom_line(aes(y=Value, colour="p=1.5")) 
vStatics <- vStatics + geom_line(aes(y=optimalManagement$Value, colour="p=1 (baseline)"))
vStatics <- vStatics + scale_colour_manual(values=c("blue", "red"))
vStatics <- vStatics + labs(y = "Value", x= "Stock", colour = "Parameter")
vStatics <- vStatics + theme(legend.position = c(0.9,0.6))
vStatics
```



```{r echo = FALSE, eval=FALSE}
harvestStatics <- ggplot(optimalManagement_a, aes(x=Stock)) 
harvestStatics <- harvestStatics + geom_line(aes(y=Harvest, colour="a=1.15")) 
harvestStatics <- harvestStatics + geom_line(aes(y=optimalManagement$Harvest, colour="a=0.75 (baseline)"))
harvestStatics <- harvestStatics + scale_colour_manual(values=c("blue", "red"))
harvestStatics <- harvestStatics + labs(y = "Optimal Harvest", x= "Stock", colour = "Parameter")
harvestStatics <- harvestStatics + theme(legend.position = c(0.6,0.8))
harvestStatics
```


```{r echo = FALSE, eval=FALSE}
vStatics <- ggplot(optimalManagement_a, aes(x=Stock)) 
vStatics <- vStatics + geom_line(aes(y=Value, colour="a=1.15")) 
vStatics <- vStatics + geom_line(aes(y=optimalManagement$Value, colour="a=0.75 (baseline)"))
vStatics <- vStatics + scale_colour_manual(values=c("blue", "red"))
vStatics <- vStatics + labs(y = "Value", x= "Stock", colour = "Parameter")
vStatics <- vStatics + theme(legend.position = c(0.9,0.6))
vStatics
```



```{r echo = FALSE, eval=FALSE}
harvestStatics <- ggplot(optimalManagement_beta, aes(x=Stock)) 
harvestStatics <- harvestStatics + geom_line(aes(y=Harvest, colour="beta = 0.875"))
harvestStatics <- harvestStatics + geom_line(aes(y=optimalManagement$Harvest, colour="beta=0.95 (basline)"))
harvestStatics <- harvestStatics + scale_colour_manual(values=c("red", "blue"))
harvestStatics <- harvestStatics + labs(y = "Optimal Harvest", x= "Stock", colour = "Parameter")
harvestStatics <- harvestStatics + theme(legend.position = c(0.6,0.8))
harvestStatics
```


```{r echo = FALSE, eval=FALSE}
vStatics <- ggplot(optimalManagement_beta, aes(x=Stock)) 
vStatics <- vStatics + geom_line(aes(y=Value, colour="beta=0.875"))
vStatics <- vStatics + geom_line(aes(y=optimalManagement$Value, colour="beta=0.95 (baseline)"))
vStatics <- vStatics + scale_colour_manual(values=c("red", "blue"))
vStatics <- vStatics + labs(y = "Value", x= "Stock", colour = "Parameter")
vStatics <- vStatics + theme(legend.position = c(0.9,0.6))
vStatics
```



Now we use our model to predict the expected path of the fish over a $10$ period planning horizon when the fishery is managed under the optimal policy. For that we need the stock size at date $t=0$. We were given that information ie., the stock size at date $t=0$ is $X_0 = 0.1$.


```{r eval=FALSE}
#This function returns optimal escapement for each stock value
optimalEsc <- function(x_0){
  
      st <- (x_0+x_l)/2
      xt <- x_0
      #Here we perform the optimization            
      opts <- list("algorithm"="NLOPT_LD_MMA", "xtol_rel"=1.0e-8)            
      opt <- nloptr(x0 = st, eval_f = valueFunction, eval_grad_f = grad_valueFunction,  
                    xt=xt, lb = x_l, ub = x_space[j], opts=opts)
      
      s_star <- opt$solution
      # h_star <- xt - s_start
      
      # result <- c(s_star, h_star)
      return(s_star)
}
```

```{r eval=FALSE}

x_0 <- 0.1
t <- 10

x_predict <- matrix(0,nrow=t,ncol=1)
lower_bound <- matrix(0,nrow=t,ncol=1)
upper_bound <- matrix(0,nrow=t,ncol=1)


#To get confidence intervals we draw a random variable from uniform and then calculate the intervals. Let's say we draw 1000 of those random variables
ran_draw <- 1000
x_pp <- matrix(0,nrow=ran_draw, ncol=t)
z_r <- matrix(0, nrow=ran_draw , ncol=t)


z_cd <- as.matrix(z_cdfms, ncol=1)
zz <- as.matrix(z,ncol=1)

for (j  in 1:t) {
  for(i in 1:ran_draw){
     r <- runif(1)
     df <- abs(r - z_cd)
     row_ind <- which(df==min(df))[1]
     z_r[i,j] <- zz[row_ind,]
  }
}






x_p <- x_0
for(i in 1:t){
  s_prime <- optimalEsc(x_p)
  
  x_predict[i,] <- s_prime + mean(z_r[,i]) * r * s_prime * (1 - (s_prime/K) ) 
  x_pp[,i] <- s_prime + z_r[,i] * r * s_prime * (1 - (s_prime/K) )
  
  upper_bound[i,] <- quantile(x_pp[,i], .975)
  lower_bound[i,] <- quantile(x_pp[,i], .025)
  x_p <- x_predict[i,]
}

period <- matrix(seq(from=1, to=10),ncol=1)
stockPath <- cbind(period,lower_bound, x_predict, upper_bound) %>% as.data.frame()

names(stockPath) <- c("Period","LB", "Prediction", "UB")
```


```{r echo = FALSE, eval=FALSE}
stockPlot <- ggplot(stockPath, aes(x=Period))
stockPlot <- stockPlot + geom_line(aes(y=UB, colour="UB"))
stockPlot <- stockPlot + geom_line(aes(y=LB, colour="LB"))
stockPlot <- stockPlot + geom_line(aes(y=Prediction, colour="Prediction"))
stockPlot <- stockPlot + scale_colour_manual(values=c("blue", "red", "blue"))
stockPlot <- stockPlot + labs(y = "Prediction", x= "Period", colour = "Estimates")
stockPlot
```























