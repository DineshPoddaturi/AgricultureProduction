  #### Settings ####
  rm(list=ls())
  package_list <- c("abind", "evd", "plyr", "ivpack")
  lapply(package_list, require, character.only=TRUE)

  # County matrix 
  G_width <- 14; G <- matrix(1:c(G_width^2), ncol=G_width)
  
  # Brewer matrix
  B <- matrix(rep(F, length(G)), ncol=G_width)
  # B[which(G %in% sample(1:length(G), 15, replace=F))] <- T
  # Assign local brewers to selected counties
  B[which(G %in% c(2,  12,  33,  39,  41,  44,  54,  62,  73, 136, 141, 142, 147, 164, 183))] <- T
  
  # Parameter values 
  beta_p <- -1; beta_x1 <- 1; beta_x2 <- 1; beta_nat <- 0.75; beta_loc <- 1; beta_indep <- 1.25
  county_length <- length(G)
  
  # Matrix of national brewers and their subsidiaries 
  # brew_nat <- c(length(G)+1):c(length(G)+5)
  brew_nat <- c(length(G)+1):c(length(G)+5)

  # Initialize the price matrix 
  P <- lapply(1:c(county_length+length(brew_nat)), function(x) G*NA)
  
  # Observable characteristics
  x1 <- runif(c(county_length + length(brew_nat))); x1[G[B==F]] <- NA
  x2 <- runif(c(county_length + length(brew_nat))); x2[G[B==F]] <- NA
  
  # Local brewer that gets "bought out" 
  buyout <- matrix(brew_nat[1:4], ncol=2)
  # buyout <- rbind(brew_nat[c(1,3)], brew_nat[c(2,4)])
  colnames(buyout) <- c("loc", "nat")
  ownership <- matrix(0, ncol=c(county_length + length(brew_nat)), nrow=c(county_length + length(brew_nat)))
  for (b in c(G[B==T], brew_nat)) {ownership[b,b] <- 1}
  for (x in 1:dim(buyout)[1]) {ownership[buyout[x,1], buyout[x,2]] <- 1; ownership[buyout[x,2], buyout[x,1]] <- 1}
                                                                                                                
  # Dummy for local or national and independent
  dummy_indep <- rep(0, c(county_length + length(brew_nat))); dummy_indep[G[B==F]] <- NA; dummy_indep[G[B==T]] <- 1
  dummy_loc <- rep(0, c(county_length + length(brew_nat))); dummy_loc[G[B==F]] <- NA; dummy_loc[buyout[,1]] <- 1
  dummy_nat <- rep(0, c(county_length + length(brew_nat))); dummy_nat[G[B==F]] <- NA; dummy_nat[setdiff(brew_nat, buyout[,1])] <- 1
  
  # Unobservables 
  xi <- rnorm(c(county_length + length(brew_nat))); xi[G[B==F]] <- NA
  
  # Random coefficients 
  rc1 <- 0.8*matrix(rnorm(c(500*county_length), mean=0, sd=1), ncol=county_length)
  rc2 <- 0.8*matrix(rnorm(c(500*county_length), mean=0, sd=1), ncol=county_length)
  rc3 <- 0.8*matrix(rnorm(c(500*county_length), mean=0, sd=1), ncol=county_length)
  
  # Market reach parameter ("r")
  # reach <- sample(2:4, length(G), replace=T); reach[G[B==F]] <- NA
  reach <- rep(5, length(G)); reach[G[B==F]] <- NA

  # Marginal costs 
  C_shocks1 <- matrix(rnorm(c(county_length*c(length(G)+length(brew_nat))), mean=0, sd=1)/8, nrow=county_length)
  C_shocks2 <- matrix(rnorm(c(county_length*c(length(G)+length(brew_nat))), mean=0, sd=1)/10, nrow=county_length)
  C <- exp(C_shocks1)*exp(C_shocks2)
  C[col(C) %in% brew_nat] <- 0.8*C[col(C) %in% brew_nat]
  
  #### Functions ####
  
  # Neighboring counties; returns counties served by the brewer
  neighbor <- function(brewer) {
    # Return counties that are N, NE, E, SE, S, SW, W, NW of the own county. 
    own_row <- row(G)[which(G==brewer)] # Own county's row
    own_col <- col(G)[which(G==brewer)] # Own county's column
    g1 <- row(G)==own_row & abs(col(G)-own_col)<reach[brewer] # E, W
    g2 <- col(G)==own_col & abs(row(G)-own_row)<reach[brewer] # N, S
    g3 <- abs(col(G)-own_col)<reach[brewer] & abs(row(G)-own_row)<reach[brewer] # NW, NE, SW, SE
    return(g1 | g2 | g3)
  }
  
  # Mean utility function (conditional on rc draw)
  mean_util <- function(i, c, p) { beta_p*p + beta_x1*x1 + beta_x2*x2 + (dummy_loc==1)*(beta_loc+rc1[i, c]) + (dummy_nat==1)*(beta_nat+rc2[i, c]) + (dummy_indep==1)*(beta_indep+rc3[i, c]) +  xi }
  
  # Share using the mean utility (conditional on rc draw)
  share_fun <- function(c, p) {
    share_list <- abind(lapply(1:dim(rc1)[1], function(i) exp(mean_util(i, c, p))/(1+sum(exp(mean_util(i, c, p)), na.rm=T))), along=2)
    return(t(share_list))
  }
  
  # Retrieve price vector in the county given the price matrix P 
  price <- function(county, P) {
    sapply(1:c(length(G)+length(brew_nat)), function(brewer) P[[brewer]][G==county])  
  }

  # Retrieve each brewer's price in the county
  price_mat <- function(pvec, service) {
    P <- matrix(rep(NA, c(county_length*c(length(G)+length(brew_nat)))), nrow=county_length)
    for (c in 1:county_length) {
      br <- (col(service)[1,])[(service==1)[c,]]
      P[c, br] <- pvec[1:length(br)]
      pvec <- pvec[c(length(br)+1):length(pvec)]
    }
    return(P)
  }
  
  # Service area; counties that the brewer serves
  service_area <- function(brewer, buyout){
    if ((!brewer %in% c(buyout)) & dummy_indep[brewer]==1) {area <- neighbor(brewer) | G==brewer}
    else if (brewer %in% unique(c(buyout, brew_nat))) {area <- matrix(rep(T, length(G)), ncol=G_width)}
    else {area <- matrix(rep(NA, length(G)), ncol=G_width)}
    return(area)
  }
  
  # Service matrix; 
  service <- function(buyout) {
    service <- matrix(rep(0, c(county_length*c(length(G)+length(brew_nat)))), nrow=county_length)
    for (c in 1:dim(service)[1]) {
      for (b in c(G[B==T], brew_nat)) {
        if (service_area(b, buyout)[c]==T) {service[c, b] <- 1}
      }
    }
    return(service)
  }
  
  foc <- function(c, p, own, share_all) {
    brewers <- which(!is.na(p))
    deriv <- matrix(rep(0, c(length(brewers)^2)), ncol=c(length(brewers)))
    share <- apply(share_all, 2, function(x) mean(x))[brewers]
    mc <- C[c, brewers]
    deriv[col(deriv)==row(deriv)] <- apply(share_all*(1-share_all)*beta_p, 2, function(x) mean(x))[brewers]
    cr <- combn(brewers, 2)
    deriv[col(deriv)<row(deriv)] <- sapply(1:ncol(cr), function(crx) mean(share_all[,cr[,crx][1]]*share_all[,cr[,crx][2]]*(-beta_p)))
    deriv[col(deriv)>row(deriv)] <- t(deriv)[col(deriv)>row(deriv)]
    p_new <- mc - solve(deriv*own[brewers, brewers])%*%share
    return(p_new)
  }
  
  # Convergence function 
  pvec_try_fun <- function(pvec, own, buyout) {
    service <- service(buyout)
    P_try <- price_mat(pvec, service)
    share_all <- lapply(1:county_length, function(c) share_fun(c, P_try[c,]))
    pvec <- abind(sapply(1:county_length, function(c) foc(c, P_try[c,], own, share_all[[c]])), along=1)
    return(pvec)
  }
  
  ####################################### PRE-BUYOUT #######################################
  
  # Run until convergence
  pvec_try <- c(sapply(1:county_length, function(c) sapply(c(G[B==T], brew_nat), function(b) {
    if (service_area(b, buyout)[c]==T) {
      return(C[c, b])
    }
    else {return (NA)}
  } )))
  pvec_try <- pvec_try[!is.na(pvec_try)]
  sum((apply(service(buyout), 1, sum)-3)<2)
  err <- 2; max_err <- 10^-10
  
  while (err>max_err) {
    pvec_try_new <- pvec_try_fun(pvec_try, ownership, buyout)
    e <- (pvec_try_new - pvec_try)
    err <- sum(e^2)
    cat("\n Objective: ", err)
    cat("\n Max error: ", max(abs(e)), "\n")
    pvec_try <- pvec_try_new
  }
  v <- pvec_try
  P <- price_mat(v, service(buyout))
  
  ######################################### RESULTS #########################################
  # Shares
  share_pre <- lapply(1:county_length, function(c) share_fun(c, P[c,]))
  share_pre <- t(abind(lapply(1:county_length, function(c) apply(share_pre[[c]], 2, mean)), along=2))
  share_pre_mean <- apply(share_pre, 2, mean, na.rm=T)
  
  # Derivatives 
  deriv <- function(c, p, own, share_all) {
    brewers <- which(!is.na(p))
    deriv <- matrix(rep(0, c(length(brewers)^2)), ncol=c(length(brewers)))
    share <- apply(share_all, 2, function(x) mean(x))[brewers]
    deriv[col(deriv)==row(deriv)] <- apply(share_all*(1-share_all)*beta_p, 2, function(x) mean(x))[brewers]
    cr <- combn(brewers, 2)
    deriv[col(deriv)<row(deriv)] <- sapply(1:ncol(cr), function(crx) mean(share_all[,cr[,crx][1]]*share_all[,cr[,crx][2]]*(-beta_p)))
    deriv[col(deriv)>row(deriv)] <- t(deriv)[col(deriv)>row(deriv)]
    return(deriv)
  }
  share_all <- lapply(1:county_length, function(c) share_fun(c, P[c,]))
  deriv <- lapply(1:county_length, function(c) deriv(c, P[c,], ownership, share_all[[c]]))
  
  #################################### DEMAND ESTIMATION ####################################
  # Pure logit 
  out_share <- matrix(rep(1-apply(share_pre, 1, sum, na.rm=T), c(dim(share_pre)[2])), ncol=dim(share_pre)[2])
  group_share <- share_pre/cbind(matrix(rep(apply(share_pre, 1, function(x) sum(x[1:county_length], na.rm=T)), county_length), ncol=county_length),
                        matrix(rep(apply(share_pre[,c(county_length+1):dim(share_pre)[2]], 1, sum, na.rm=T), c(dim(share_pre)[2]-(county_length))), ncol=c(dim(share_pre)[2]-(county_length))))
  x1_mat <- matrix(rep(x1, dim(share_pre)[1]), ncol=dim(share_pre)[2], byrow = T)
  x2_mat <- matrix(rep(x2, dim(share_pre)[1]), ncol=dim(share_pre)[2], byrow = T)
  dummy_loc_mat <- matrix(rep(dummy_loc, dim(share_pre)[1]), ncol=dim(share_pre)[2], byrow = T)
  dummy_indep_mat <- matrix(rep(dummy_indep, dim(share_pre)[1]), ncol=dim(share_pre)[2], byrow = T)
  dummy_nat_mat <- matrix(rep(dummy_nat, dim(share_pre)[1]), ncol=dim(share_pre)[2], byrow = T)
  xi_mat <- matrix(rep(xi, dim(share_pre)[1]), ncol=dim(share_pre)[2], byrow = T)
  share_df <- data.frame(cbind(c(P), c(share_pre), c(out_share), c(group_share), c(x1_mat), c(x2_mat), c(dummy_loc_mat), c(dummy_indep_mat), c(dummy_nat_mat),
                    c(xi_mat), c(C_shocks1), c(C_shocks2)))
  names(share_df) <- c("price", "share", "out_share", "group_share", "x1", "x2", "dummy_loc", "dummy_indep", "dummy_nat", 
                       "xi", "cost1", "cost2")
  share_df$log_share <- log(share_df$share) - log(share_df$out_share)
  share_df$log_group_share <- log(share_df$group_share)
  lm1 <- lm(log_share ~ price + x1 + x2 + dummy_loc + dummy_nat, share_df)
  lm2 <- ivreg(log_share ~ price + x1 + x2 + dummy_loc + dummy_nat |
                x1 + x2 + dummy_loc + dummy_nat + cost2, data=share_df)
  
  # Nested logit 
  # Sum of competing product characteristics as BLP instruments 
  blp1 <- matrix(rep(apply(x1_mat*!is.na(share_pre), 1, sum, na.rm=T), dim(share_pre)[2]), ncol=dim(share_pre)[2], byrow=F) - x1_mat
  share_df$blp1 <- c(blp1)
  blp2 <- matrix(rep(apply(x2_mat*!is.na(share_pre), 1, sum, na.rm=T), dim(share_pre)[2]), ncol=dim(share_pre)[2], byrow=F) - x2_mat
  share_df$blp2 <- c(blp2)
  summary(lm(log_share ~ price + x1 + x2 + dummy_loc + dummy_nat + log(group_share), share_df))
  summary(ivreg(log_share ~ price + x1 + x2 + dummy_loc + dummy_nat + log(group_share) |
                  x1 + x2 + dummy_loc + dummy_nat + cost1 + blp2, data=share_df))
  lm1 <- lm(log_share ~ price + x1 + x2 + dummy_loc + dummy_nat + log(group_share), share_df)
  lm2 <- ivreg(log_share ~ price + x1 + x2 + dummy_loc + dummy_nat + log(group_share) |
          x1 + x2 + dummy_loc + dummy_nat + cost1 + blp1, data=share_df)
  
  # Estimated derivatives 
  # Derivatives 
  deriv_est <- function(c, p, own, share, parm) {
    brewers <- which(!is.na(p))
    deriv <- matrix(rep(0, c(length(brewers)^2)), ncol=c(length(brewers)))
    deriv[col(deriv)==row(deriv)] <- (share*(1-share)*parm)[brewers]
    cr <- combn(brewers, 2)
    deriv[col(deriv)<row(deriv)] <- sapply(1:ncol(cr), function(crx) mean(share[cr[,crx][1]]*share[cr[,crx][2]]*(-parm)))
    deriv[col(deriv)>row(deriv)] <- t(deriv)[col(deriv)>row(deriv)]
    return(deriv)
  }
  deriv_est1 <- lapply(1:county_length, function(c) deriv_est(c, P[c,], ownership, share_pre[c,], lm1$coefficients["price"]))
  deriv_est2 <- lapply(1:county_length, function(c) deriv_est(c, P[c,], ownership, share_pre[c,], lm2$coefficients["price"]))
  plot(abind(sapply(c(1:county_length), function(c) cbind(c(deriv[[c]]),c(deriv_est1[[c]]))), along=1))
  points(abind(sapply(c(1:county_length), function(c) cbind(c(deriv[[c]]),c(deriv_est2[[c]]))), along=1), col="blue")
  abline(a=0, b=1, col="red")
  
  ####################################### POST-BUYOUT #######################################
  
  # Update buyout matrix 
  buyout2 <- rbind(buyout, c(G[B==T][1], brew_nat[length(brew_nat)]))
  # buyout <- rbind(brew_nat[c(1,3)], brew_nat[c(2,4)])
  colnames(buyout) <- c("loc", "nat")
  ownership2 <- matrix(0, ncol=c(county_length + length(brew_nat)), nrow=c(county_length + length(brew_nat)))
  for (b in c(G[B==T], brew_nat)) {ownership2[b,b] <- 1}
  for (x in 1:dim(buyout2)[1]) {ownership2[buyout2[x,1], buyout2[x,2]] <- 1; ownership2[buyout2[x,2], buyout2[x,1]] <- 1}
  
  C[,buyout2[dim(buyout2)[1],1]] <- C[,buyout2[dim(buyout2)[1],2]]
  dummy_indep[buyout2[dim(buyout2)[1],1]] <- 0
  dummy_loc[buyout2[dim(buyout2)[1],1]] <- 1
  
  # Run until convergence
  # We should be using the parameter estimates for this merger simulation. 
  # This version is using the true model parameters. 
  pvec_try <- c(sapply(1:county_length, function(c) sapply(c(G[B==T], brew_nat), function(b) {
    if (service_area(b, buyout2)[c]==T) {
      return(C[c, b])
    }
    else {return (NA)}
  } )))
  pvec_try <- pvec_try[!is.na(pvec_try)]
  sum((apply(service(buyout2), 1, sum)-3)<2)
  err <- 2; max_err <- 10^-10
  
  while (err>max_err) {
    pvec_try_new <- pvec_try_fun(pvec_try, ownership2, buyout2)
    e <- (pvec_try_new - pvec_try)
    err <- sum(e^2)
    cat("\n Objective: ", err)
    cat("\n Max error: ", max(abs(e)), "\n")
    pvec_try <- pvec_try_new
  }
  v_buyout <- pvec_try
  P_buyout <- price_mat(v_buyout, service(buyout2))
  
  # Shares
  share_post <- lapply(1:county_length, function(c) share_fun(c, P_buyout[c,]))
  share_post <- t(abind(lapply(1:county_length, function(c) apply(share_post[[c]], 2, mean)), along=2))
  share_post_mean <- apply(share_post, 2, mean, na.rm=T)
  
  # Compare shares and prices before/after buyout
  share_pre-share_post
  share_pre_mean-share_post_mean
  (P-P_buyout)[,G[B==T][3]]